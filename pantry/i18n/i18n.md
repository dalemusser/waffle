# i18n - Internationalization & Localization

The `i18n` package provides complete internationalization (i18n) and localization (L10n) support for Go web applications, including translation management, locale detection, pluralization, and locale-aware formatting.

## Features

**Internationalization (i18n):**
- Translation bundles with multiple locales
- Fallback locale support
- JSON file loading (flat and nested)
- HTTP middleware for automatic locale detection
- Accept-Language header parsing
- Pluralization rules for 25+ languages
- Go template integration
- Context-based localizer access
- Thread-safe design

**Localization (L10n):**
- Number formatting (1234.56 → "1,234.56" or "1.234,56")
- Currency formatting with locale-specific symbols and positions
- Date/time formatting with localized month and day names
- Relative time formatting ("2 hours ago", "in 3 days")
- List formatting with locale-appropriate conjunctions
- RTL (right-to-left) language detection
- Support for 25+ locales out of the box

## Installation

```go
import "github.com/yourusername/waffle/i18n"
```

## Quick Start

```go
package main

import (
    "net/http"

    "github.com/yourusername/waffle/i18n"
)

func main() {
    // Create a bundle with default locale
    bundle := i18n.NewBundle("en")

    // Add translations
    bundle.AddMessages("en", map[string]string{
        "greeting":     "Hello, %s!",
        "items.one":    "You have {{.Count}} item",
        "items.other":  "You have {{.Count}} items",
    })

    bundle.AddMessages("es", map[string]string{
        "greeting":     "¡Hola, %s!",
        "items.one":    "Tienes {{.Count}} artículo",
        "items.other":  "Tienes {{.Count}} artículos",
    })

    // Create middleware
    mw := i18n.Middleware(i18n.DefaultMiddlewareConfig(bundle))

    // Use in handler
    http.Handle("/", mw(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        l := i18n.FromContext(r.Context())

        // Simple translation
        greeting := l.T("greeting", "World")

        // Plural translation
        items := l.TPlural("items", 5)

        w.Write([]byte(greeting + "\n" + items))
    })))

    http.ListenAndServe(":8080", nil)
}
```

## Bundle

The `Bundle` holds translations for all locales:

```go
// Create with default locale
bundle := i18n.NewBundle("en")

// Set fallback locale (defaults to default locale)
bundle.SetFallbackLocale("en")

// Custom missing key handler
bundle.SetMissingKeyFunc(func(locale, key string) string {
    log.Printf("Missing translation: %s/%s", locale, key)
    return key
})
```

### Adding Translations

```go
// Add messages directly
bundle.AddMessages("en", map[string]string{
    "welcome": "Welcome!",
    "goodbye": "Goodbye!",
})

// Load from JSON file
err := bundle.LoadJSON("en", "locales/en.json")

// Load from nested JSON (keys are flattened with dots)
err := bundle.LoadNestedJSON("en", "locales/en.json")

// Load all JSON files from directory
// Files should be named {locale}.json (en.json, fr.json, etc.)
err := bundle.LoadJSONDir("locales")
```

### JSON File Formats

**Flat JSON** (LoadJSON):
```json
{
    "welcome": "Welcome!",
    "errors.required": "This field is required",
    "errors.invalid": "Invalid value"
}
```

**Nested JSON** (LoadNestedJSON):
```json
{
    "welcome": "Welcome!",
    "errors": {
        "required": "This field is required",
        "invalid": "Invalid value"
    }
}
```

## Localizer

The `Localizer` translates messages for a specific locale:

```go
// Get localizer from bundle
l := bundle.Localizer("es")

// Check locale
fmt.Println(l.Locale()) // "es"

// Check if key exists
if l.Has("welcome") {
    // ...
}
```

### Translation Methods

**Simple Translation (T)**:
```go
// No arguments
l.T("welcome") // "Welcome!"

// Printf-style arguments
l.T("greeting", "World") // "Hello, World!" (from "Hello, %s!")

// Template arguments
l.T("welcome_user", map[string]any{
    "Name": "Alice",
    "Role": "Admin",
}) // "Welcome, Alice (Admin)!" (from "Welcome, {{.Name}} ({{.Role}})!")
```

**Plural Translation (TPlural / N)**:
```go
// Automatic plural form selection
l.TPlural("items", 1)  // "You have 1 item"
l.TPlural("items", 5)  // "You have 5 items"

// With additional template data
l.TPlural("cart_items", 3, map[string]any{
    "Total": "$29.99",
}) // "You have 3 items ($29.99 total)"

// N is an alias for TPlural
l.N("items", 1)
```

### Plural Keys

Define plural forms with suffixes:
```json
{
    "items.zero": "You have no items",
    "items.one": "You have {{.Count}} item",
    "items.two": "You have {{.Count}} items",
    "items.few": "You have {{.Count}} items",
    "items.many": "You have {{.Count}} items",
    "items.other": "You have {{.Count}} items"
}
```

Available plural forms: `zero`, `one`, `two`, `few`, `many`, `other`

The count is automatically available as `{{.Count}}` in templates.

## HTTP Middleware

The middleware detects locale and adds a `Localizer` to the request context:

```go
cfg := i18n.MiddlewareConfig{
    Bundle:       bundle,
    CookieName:   "lang",      // Default: "lang"
    QueryParam:   "lang",      // Default: "lang"
    SetCookie:    true,        // Set cookie when locale detected
    CookieMaxAge: 86400 * 365, // 1 year
    CookiePath:   "/",
}

mw := i18n.Middleware(cfg)
```

### Locale Detection Order

Default detection order:
1. Query parameter (`?lang=es`)
2. Cookie (`lang=es`)
3. Accept-Language header

### Custom Detectors

```go
cfg := i18n.MiddlewareConfig{
    Bundle: bundle,
    Detectors: []i18n.LocaleDetector{
        // URL path prefix (/en/page, /es/page)
        i18n.PathDetector(),

        // Query parameter
        i18n.QueryDetector("locale"),

        // Cookie
        i18n.CookieDetector("user_lang"),

        // Accept-Language header
        i18n.HeaderDetector(),

        // Custom session-based
        i18n.SessionDetector(func(r *http.Request) string {
            // Get from session
            return getSession(r).Get("locale")
        }),
    },
}
```

### Accept-Language Parsing

```go
// Get preferred locale
locale := i18n.ParseAcceptLanguage("en-US,en;q=0.9,es;q=0.8")
// Returns: "en-US"

// Get all locales sorted by preference
locales := i18n.ParseAcceptLanguageAll("en-US,en;q=0.9,es;q=0.8")
// Returns: ["en-US", "en", "es"]

// Find best match from available locales
available := []string{"en", "es", "fr"}
best := i18n.BestMatch("en-US,de;q=0.9,es;q=0.8", available)
// Returns: "en" (matches en-US base language)
```

## Context Integration

```go
// In middleware or handler setup
ctx := i18n.WithLocalizer(r.Context(), localizer)

// In handler
l := i18n.FromContext(ctx)
if l != nil {
    msg := l.T("welcome")
}

// Convenience functions (return key if no localizer)
msg := i18n.T(ctx, "welcome")
items := i18n.TPlural(ctx, "items", count)
```

## Global Bundle

For simple applications:

```go
// Set global bundle
i18n.SetGlobalBundle(bundle)

// Use anywhere
msg := i18n.Global("welcome")
msg := i18n.GlobalWithLocale("es", "welcome")

// Get bundle
bundle := i18n.GetGlobalBundle()
```

## Pluralization Rules

The package includes pluralization rules for many languages:

| Language Family | Languages | Forms Used |
|-----------------|-----------|------------|
| Germanic | en, de, nl, sv, da, no | one, other |
| Romance | fr, pt | one (0-1), other |
| Romance | es, it, ca | one, other |
| Slavic | ru, uk, be, hr, sr | one, few, many |
| Slavic | pl | one, few, many |
| Slavic | cs, sk | one, few, other |
| Semitic | ar | zero, one, two, few, many, other |
| Asian | ja, zh, ko, vi, th | other (no plural) |
| Baltic | lt | one, few, other |
| Baltic | lv | zero, one, other |
| Celtic | ga (Irish) | one, two, few, many, other |
| Celtic | cy (Welsh) | zero, one, two, few, many, other |
| Other | ro, tr | varies |

### Custom Plural Rules

```go
// Register custom plural function
bundle.RegisterPluralFunc("my-locale", func(n int) i18n.PluralForm {
    if n == 1 {
        return i18n.PluralOne
    }
    return i18n.PluralOther
})
```

## Template Functions

Add custom functions for use in templates:

```go
bundle.templateFuncs["upper"] = strings.ToUpper
bundle.templateFuncs["formatMoney"] = func(amount float64) string {
    return fmt.Sprintf("$%.2f", amount)
}

// In translation: "Total: {{formatMoney .Amount}}"
```

## Bundle Methods Reference

| Method | Description |
|--------|-------------|
| `NewBundle(defaultLocale)` | Create new bundle |
| `SetFallbackLocale(locale)` | Set fallback locale |
| `SetMissingKeyFunc(fn)` | Custom missing key handler |
| `AddLocale(tag, messages)` | Add locale messages |
| `AddMessages(locale, messages)` | Alias for AddLocale |
| `LoadJSON(locale, path)` | Load flat JSON file |
| `LoadNestedJSON(locale, path)` | Load nested JSON file |
| `LoadJSONDir(dir)` | Load all JSON from directory |
| `Locales()` | List all locale tags |
| `HasLocale(locale)` | Check if locale exists |
| `DefaultLocale()` | Get default locale |
| `Localizer(locale)` | Get localizer for locale |
| `T(key, args...)` | Translate with default locale |
| `TWithLocale(locale, key, args...)` | Translate with specific locale |
| `RegisterPluralFunc(locale, fn)` | Register custom plural rules |

## Localizer Methods Reference

| Method | Description |
|--------|-------------|
| `Locale()` | Get localizer's locale |
| `T(key, args...)` | Translate message |
| `TPlural(key, count, args...)` | Translate with pluralization |
| `N(key, count, args...)` | Alias for TPlural |
| `Has(key)` | Check if key exists |

## Middleware Functions Reference

| Function | Description |
|----------|-------------|
| `Middleware(cfg)` | Create locale detection middleware |
| `DefaultMiddlewareConfig(bundle)` | Get default config |
| `QueryDetector(param)` | Detect from query param |
| `CookieDetector(name)` | Detect from cookie |
| `HeaderDetector()` | Detect from Accept-Language |
| `PathDetector()` | Detect from URL path prefix |
| `SessionDetector(getter)` | Detect from session |
| `ParseAcceptLanguage(header)` | Parse preferred locale |
| `ParseAcceptLanguageAll(header)` | Parse all locales |
| `BestMatch(header, available)` | Find best matching locale |

## Best Practices

1. **Organize translations by feature**:
   ```
   locales/
     en/
       common.json
       auth.json
       products.json
     es/
       common.json
       auth.json
       products.json
   ```

2. **Use namespaced keys**:
   ```json
   {
       "auth.login": "Log In",
       "auth.logout": "Log Out",
       "products.add_to_cart": "Add to Cart"
   }
   ```

3. **Always provide fallback locale translations**

4. **Use plural forms correctly** - different languages have different rules

5. **Test with RTL languages** if supporting Arabic, Hebrew, etc.

6. **Cache localizers** when possible for performance

## Thread Safety

All bundle operations are thread-safe. The bundle uses read-write locks to allow concurrent reads while serializing writes.

```go
// Safe to call from multiple goroutines
go bundle.T("key1")
go bundle.T("key2")
go bundle.AddMessages("fr", messages) // Blocks readers briefly
```

## Localization (L10n) Features

The package includes comprehensive localization support for formatting numbers, currencies, dates, and more according to locale conventions.

### Number Formatting

```go
l := bundle.Localizer("de")

// Basic number formatting
l.FormatNumber(1234.56)              // "1.234,56" (German uses . for thousands, , for decimal)
l.FormatNumberWithPrecision(1234.5, 2) // "1.234,50"

// Integer formatting
l.FormatInteger(1234567)             // "1.234.567"

// Percentage formatting
l.FormatPercent(0.156)               // "16%"
l.FormatPercentWithPrecision(0.156, 1) // "15,6%"
```

**Locale differences:**

| Locale | Number 1234.56 | Number 1234567 |
|--------|----------------|----------------|
| en | 1,234.56 | 1,234,567 |
| de | 1.234,56 | 1.234.567 |
| fr | 1 234,56 | 1 234 567 |
| ar | ١٬٢٣٤٫٥٦ | ١٬٢٣٤٬٥٦٧ |

### Currency Formatting

```go
l := bundle.Localizer("en")
l.FormatCurrency(1234.56, "USD")     // "$1,234.56"
l.FormatCurrency(1234.56, "EUR")     // "€1,234.56"

l = bundle.Localizer("de")
l.FormatCurrency(1234.56, "EUR")     // "1.234,56 €"
l.FormatCurrency(1234.56, "USD")     // "1.234,56 $"

l = bundle.Localizer("ja")
l.FormatCurrency(1234, "JPY")        // "¥1,234" (no decimals for Yen)
```

**Supported currencies by locale:**

| Locale | Currencies |
|--------|------------|
| en | USD, EUR, GBP |
| de, fr, it, es | EUR, USD |
| ja | JPY, USD |
| zh | CNY, USD |
| ru | RUB, USD |
| ar | SAR, USD |
| (and many more) | |

### Date & Time Formatting

```go
l := bundle.Localizer("en")
t := time.Date(2025, 12, 15, 14, 30, 0, 0, time.UTC)

// Date styles
l.FormatDate(t)                      // "12/15/2025" (short, default)
l.FormatDateStyle(t, "short")        // "12/15/2025"
l.FormatDateStyle(t, "medium")       // "Dec 15, 2025"
l.FormatDateStyle(t, "long")         // "December 15, 2025"
l.FormatDateStyle(t, "full")         // "Monday, December 15, 2025"

// Time formatting
l.FormatTime(t)                      // "2:30 PM"
l.FormatTime24(t)                    // "14:30"

// Date and time together
l.FormatDateTime(t)                  // "Dec 15, 2025 2:30 PM"
```

**Locale differences:**

| Locale | Short Date | Long Date |
|--------|------------|-----------|
| en | 12/15/2025 | December 15, 2025 |
| de | 15.12.2025 | 15. Dezember 2025 |
| fr | 15/12/2025 | 15 décembre 2025 |
| ja | 2025/12/15 | 2025年12月15日 |
| ar | 15/12/2025 | 15 ديسمبر 2025 |

### Relative Time Formatting

```go
l := bundle.Localizer("en")

// Past times
l.FormatRelativeTime(-2 * time.Hour)     // "2 hours ago"
l.FormatRelativeTime(-3 * 24 * time.Hour) // "3 days ago"
l.FormatRelativeTime(-2 * 7 * 24 * time.Hour) // "2 weeks ago"

// Future times
l.FormatRelativeTime(30 * time.Minute)   // "in 30 minutes"
l.FormatRelativeTime(24 * time.Hour)     // "in 1 day"

// Just now
l.FormatRelativeTime(-5 * time.Second)   // "just now"
```

You can customize relative time strings via translations:
```json
{
    "relative.now": "just now",
    "relative.seconds.one": "{{.Count}} second",
    "relative.seconds.other": "{{.Count}} seconds",
    "relative.minutes.one": "{{.Count}} minute",
    "relative.minutes.other": "{{.Count}} minutes",
    "relative.hours.one": "{{.Count}} hour",
    "relative.hours.other": "{{.Count}} hours",
    "relative.days.one": "{{.Count}} day",
    "relative.days.other": "{{.Count}} days",
    "relative.weeks.one": "{{.Count}} week",
    "relative.weeks.other": "{{.Count}} weeks",
    "relative.months.one": "{{.Count}} month",
    "relative.months.other": "{{.Count}} months",
    "relative.years.one": "{{.Count}} year",
    "relative.years.other": "{{.Count}} years",
    "relative.past": "{{.Time}} ago",
    "relative.future": "in {{.Time}}"
}
```

### List Formatting

```go
l := bundle.Localizer("en")

// And conjunction (Oxford comma for English)
l.FormatListAnd([]string{"apple", "banana", "cherry"})
// "apple, banana, and cherry"

// Or conjunction
l.FormatListOr([]string{"red", "green", "blue"})
// "red, green, or blue"

// Two items
l.FormatListAnd([]string{"cats", "dogs"})
// "cats and dogs"

// Different locale
l = bundle.Localizer("fr")
l.FormatListAnd([]string{"pomme", "banane", "cerise"})
// "pomme, banane et cerise" (no Oxford comma in French)
```

**Conjunction words by locale:**

| Locale | "and" | "or" |
|--------|-------|------|
| en | and | or |
| de | und | oder |
| fr | et | ou |
| es | y | o |
| ja | と | または |
| ar | و | أو |

### RTL Detection

```go
l := bundle.Localizer("ar")  // Arabic

// Check if locale is RTL
if l.IsRTL() {
    // Apply RTL-specific styling
}

// Get text direction for HTML
dir := l.TextDirection()  // "rtl" or "ltr"

// Use in template
// <html dir="{{.TextDirection}}">
```

**RTL Languages:**
- Arabic (ar)
- Hebrew (he)

## L10n Methods Reference

| Method | Description |
|--------|-------------|
| `FormatNumber(n)` | Format number with locale conventions |
| `FormatNumberWithPrecision(n, decimals)` | Format with specific decimal places |
| `FormatInteger(n)` | Format integer with thousand separators |
| `FormatPercent(n)` | Format as percentage (0.5 → "50%") |
| `FormatPercentWithPrecision(n, decimals)` | Format percentage with decimals |
| `FormatCurrency(amount, code)` | Format currency amount |
| `FormatDate(t)` | Format date (short style) |
| `FormatDateStyle(t, style)` | Format date with style (short/medium/long/full) |
| `FormatTime(t)` | Format time (locale default) |
| `FormatTime24(t)` | Format time in 24-hour format |
| `FormatDateTime(t)` | Format date and time together |
| `FormatRelativeTime(d)` | Format duration as relative time |
| `FormatRelativeTimeFrom(from, d)` | Format relative time from reference |
| `FormatList(items, conj)` | Format list with conjunction |
| `FormatListAnd(items)` | Format list with "and" |
| `FormatListOr(items)` | Format list with "or" |
| `IsRTL()` | Check if locale is right-to-left |
| `TextDirection()` | Get "rtl" or "ltr" |

## Supported Locales

The package includes full L10n support for:

| Code | Language | RTL |
|------|----------|-----|
| en | English | No |
| de | German | No |
| fr | French | No |
| es | Spanish | No |
| it | Italian | No |
| pt | Portuguese | No |
| nl | Dutch | No |
| pl | Polish | No |
| ru | Russian | No |
| uk | Ukrainian | No |
| cs | Czech | No |
| el | Greek | No |
| ro | Romanian | No |
| hu | Hungarian | No |
| tr | Turkish | No |
| sv | Swedish | No |
| da | Danish | No |
| no | Norwegian | No |
| fi | Finnish | No |
| ja | Japanese | No |
| zh | Chinese | No |
| ko | Korean | No |
| th | Thai | No |
| vi | Vietnamese | No |
| id | Indonesian | No |
| ms | Malay | No |
| hi | Hindi | No |
| ar | Arabic | Yes |
| he | Hebrew | Yes |

### Adding Custom Locale Formats

You can access and modify locale formats programmatically:

```go
// Get format for a locale
fmt := i18n.GetLocaleFormat("en")

// Access properties
fmt.Number.DecimalSeparator   // "."
fmt.Number.ThousandSeparator  // ","
fmt.Currency["USD"].Symbol    // "$"
fmt.Date.Short               // "01/02/2006"
fmt.IsRTL                    // false
```
